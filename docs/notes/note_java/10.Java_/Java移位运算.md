---
title: Java移位运算,运算符
createTime: 2024/11/08 11:41:33
permalink: /note_java/ao57y1x3/
---



| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

<br>

|=：两个二进制对应位都为0时，结果等于0，否则结果等于1；

&=：两个二进制的对应位都为1时，结果为1，否则结果等于0；

^=：两个二进制的对应位相同，结果为0，否则结果为1。

## |= 位或运算符

```text
|= 运算符和 += 这一类的运算符一样，拆解开就是 a = a | b；
```

运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。

比如：129|128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.

## &= 位与运算符

```text
&= 运算符和 += 这一类的运算符一样，拆解开就是 a = a & b；
```

运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。

比如：129&128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.

## ^= 位异或运算

```text
^= 运算符和 += 这一类的运算符一样，拆解开就是 a = a^b；
```

运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。

比如：8^11.

8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是`Integer.parseInt(“0011”,2)=3`;
也就是说对同一个字符进行两次异或运算就会回到原来的值。

## ~= 位非运算符

运算规则：如果位为0，结果是1，如果位为1，结果是0.

比如：~37

在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.

8转为二进制是100101.

补码后为： 00000000 00000000 00000000 00100101

取反为： 11111111 11111111 11111111 11011010

因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。

因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：

00000000 00000000 00000000 00100110，此时二进制转原码为38

所以~37 = -38.



```java
public class Test {
    public static void main(String args[]) {
        int a1 = 5; // 0000 0101
        int b1 = 3; // 0000 0011
        a1 |= b1; // 0000 00111
        System.out.println("|= "+a1);
 
        int a2 = 5; // 0000 0101
        int b2 = 3; // 0000 0011
        a2 &= b2; // 0000 0001
        System.out.println("&= "+a2);
 
        int a3 = 5; // 0000 0101
        int b3 = 3; // 0000 0011
        a3 ^= b3; // 0000 0110
        System.out.println("^= "+a3);
    }
}
```




## 左移<<运算

将二进制数向左移位操作，高位溢出则丢弃，低位补0

```text
a=11;
a<<1;
移位前：0000 1011
移位后：0001 0110（十进制值为22）
```

根据上述样例我们可以发现，**对一个数左移1位就是乘以2，左移n位就是乘以2的n次方（而左移运算比乘法快得多）**

## 右移>>运算

右移位运算中，无符号数和有符号数的运算并不相同。对于无符号数，右移之后高位补0；对于有符号数，符号位一起移动，正数高位补0，负数高位补1

实际上，**右移n位就是除以2的n次方，当得到的商不是整数时会往小取整**

```text
b=5;
b<<2;
移位前：0000 0101
移位后：0001 0100（十进制值为20）
无符号数
a=16;
a>>3;
移位前：0001 0000
移位后：0000 0010（十进制值为2）
有符号数（正数）
b=32;
a>>3;
移位前：0010 0000
移位后：0000 0100（十进制值位4）
有符号数（负数）
b=-32;
b>>3;
移位前：1010 0000
移位后：1000 0100（十进制值为-4）
c=25;
c>>4;
移位前：0001 1001
移位后：0000 0001（十进制值为1）
```



